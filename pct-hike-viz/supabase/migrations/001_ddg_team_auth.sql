-- ═══════════════════════════════════════════════════════════════════════════════
-- DDG TEAM AUTHENTICATION & ACCESS CONTROL
-- ═══════════════════════════════════════════════════════════════════════════════
-- Only these emails can access the app:
--   • smileyguy@aol.com (Dan - Dad)
--   • andrew.d.hostetler@gmail.com (Drew - Brother)
--   • gunnarguy@me.com (Gunnar)
--   • gunnarguy@aol.com (Gunnar alt)
-- ═══════════════════════════════════════════════════════════════════════════════

-- 1. Allowed emails table (whitelist)
create table if not exists allowed_emails (
  email text primary key,
  hiker_id text not null,
  name text not null,
  role text default 'member',
  created_at timestamptz default now()
);

-- Populate the whitelist
insert into allowed_emails (email, hiker_id, name, role) values
  ('smileyguy@aol.com', 'dan', 'Dan', 'member'),
  ('andrew.d.hostetler@gmail.com', 'drew', 'Drew', 'member'),
  ('gunnarguy@me.com', 'gunnar', 'Gunnar', 'admin'),
  ('gunnarguy@aol.com', 'gunnar', 'Gunnar', 'admin')
on conflict (email) do nothing;

-- 2. Access requests table (for people who try to sign up but aren't whitelisted)
create table if not exists access_requests (
  id bigint generated by default as identity primary key,
  email text not null unique,
  requested_at timestamptz default now(),
  status text default 'pending' check (status in ('pending', 'approved', 'denied')),
  reviewed_by text,
  reviewed_at timestamptz,
  notes text
);

-- 3. DDG team profiles (links auth.users to hiker_id)
create table if not exists ddg_team_profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  email text not null unique,
  hiker_id text not null,
  name text not null,
  role text default 'member',
  created_at timestamptz default now()
);

-- ═══════════════════════════════════════════════════════════════════════════════
-- ROW LEVEL SECURITY (RLS)
-- ═══════════════════════════════════════════════════════════════════════════════

-- Enable RLS on all tables
alter table gear_loadouts enable row level security;
alter table custom_items enable row level security;
alter table ops_logs enable row level security;
alter table ddg_team_profiles enable row level security;
alter table access_requests enable row level security;

-- Helper function: Check if current user is a DDG team member
create or replace function is_ddg_team_member()
returns boolean as $$
begin
  return exists (
    select 1 from ddg_team_profiles
    where id = auth.uid()
  );
end;
$$ language plpgsql security definer;

-- Helper function: Check if current user is admin (Gunnar)
create or replace function is_ddg_admin()
returns boolean as $$
begin
  return exists (
    select 1 from ddg_team_profiles
    where id = auth.uid() and role = 'admin'
  );
end;
$$ language plpgsql security definer;

-- ═══════════════════════════════════════════════════════════════════════════════
-- POLICIES: gear_loadouts
-- ═══════════════════════════════════════════════════════════════════════════════
drop policy if exists "DDG team can view all loadouts" on gear_loadouts;
create policy "DDG team can view all loadouts" on gear_loadouts
  for select using (is_ddg_team_member());

drop policy if exists "DDG team can update all loadouts" on gear_loadouts;
create policy "DDG team can update all loadouts" on gear_loadouts
  for all using (is_ddg_team_member());

-- ═══════════════════════════════════════════════════════════════════════════════
-- POLICIES: custom_items
-- ═══════════════════════════════════════════════════════════════════════════════
drop policy if exists "DDG team can view custom items" on custom_items;
create policy "DDG team can view custom items" on custom_items
  for select using (is_ddg_team_member());

drop policy if exists "DDG team can manage custom items" on custom_items;
create policy "DDG team can manage custom items" on custom_items
  for all using (is_ddg_team_member());

-- ═══════════════════════════════════════════════════════════════════════════════
-- POLICIES: ops_logs
-- ═══════════════════════════════════════════════════════════════════════════════
drop policy if exists "DDG team can view ops logs" on ops_logs;
create policy "DDG team can view ops logs" on ops_logs
  for select using (is_ddg_team_member());

drop policy if exists "DDG team can manage ops logs" on ops_logs;
create policy "DDG team can manage ops logs" on ops_logs
  for all using (is_ddg_team_member());

-- ═══════════════════════════════════════════════════════════════════════════════
-- POLICIES: ddg_team_profiles
-- ═══════════════════════════════════════════════════════════════════════════════
drop policy if exists "Users can view own profile" on ddg_team_profiles;
create policy "Users can view own profile" on ddg_team_profiles
  for select using (auth.uid() = id);

drop policy if exists "DDG team can view all profiles" on ddg_team_profiles;
create policy "DDG team can view all profiles" on ddg_team_profiles
  for select using (is_ddg_team_member());

-- ═══════════════════════════════════════════════════════════════════════════════
-- POLICIES: access_requests
-- ═══════════════════════════════════════════════════════════════════════════════
-- Anyone can create an access request (they need to at least get that far)
drop policy if exists "Anyone can request access" on access_requests;
create policy "Anyone can request access" on access_requests
  for insert with check (true);

-- Only admins can view/manage access requests
drop policy if exists "Admins can view access requests" on access_requests;
create policy "Admins can view access requests" on access_requests
  for select using (is_ddg_admin());

drop policy if exists "Admins can manage access requests" on access_requests;
create policy "Admins can manage access requests" on access_requests
  for update using (is_ddg_admin());

-- ═══════════════════════════════════════════════════════════════════════════════
-- TRIGGER: Auto-create profile on signup (only for whitelisted emails)
-- ═══════════════════════════════════════════════════════════════════════════════
create or replace function handle_new_user()
returns trigger as $$
declare
  allowed_record allowed_emails%rowtype;
begin
  -- Check if email is in whitelist
  select * into allowed_record from allowed_emails where email = new.email;
  
  if found then
    -- Create profile for whitelisted user
    insert into ddg_team_profiles (id, email, hiker_id, name, role)
    values (new.id, new.email, allowed_record.hiker_id, allowed_record.name, allowed_record.role);
  else
    -- Log access request for non-whitelisted user
    insert into access_requests (email) 
    values (new.email)
    on conflict (email) do nothing;
  end if;
  
  return new;
end;
$$ language plpgsql security definer;

-- Create trigger
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute function handle_new_user();

-- ═══════════════════════════════════════════════════════════════════════════════
-- FUNCTION: Approve access request (admin only)
-- ═══════════════════════════════════════════════════════════════════════════════
create or replace function approve_access_request(
  request_email text,
  assign_hiker_id text,
  assign_name text
)
returns void as $$
begin
  if not is_ddg_admin() then
    raise exception 'Only admins can approve access requests';
  end if;
  
  -- Add to whitelist
  insert into allowed_emails (email, hiker_id, name)
  values (request_email, assign_hiker_id, assign_name)
  on conflict (email) do update set hiker_id = assign_hiker_id, name = assign_name;
  
  -- Update request status
  update access_requests
  set status = 'approved',
      reviewed_by = (select email from ddg_team_profiles where id = auth.uid()),
      reviewed_at = now()
  where email = request_email;
  
  -- If user already exists in auth.users, create their profile
  insert into ddg_team_profiles (id, email, hiker_id, name, role)
  select id, email, assign_hiker_id, assign_name, 'member'
  from auth.users
  where email = request_email
  on conflict (email) do nothing;
end;
$$ language plpgsql security definer;

-- ═══════════════════════════════════════════════════════════════════════════════
-- FUNCTION: Deny access request (admin only)
-- ═══════════════════════════════════════════════════════════════════════════════
create or replace function deny_access_request(request_email text, denial_notes text default null)
returns void as $$
begin
  if not is_ddg_admin() then
    raise exception 'Only admins can deny access requests';
  end if;
  
  update access_requests
  set status = 'denied',
      reviewed_by = (select email from ddg_team_profiles where id = auth.uid()),
      reviewed_at = now(),
      notes = denial_notes
  where email = request_email;
end;
$$ language plpgsql security definer;
